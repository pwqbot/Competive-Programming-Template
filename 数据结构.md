---
title: 数据结构
categories:
  - ACM
  - 模板
---



## 线段树

### 基础模板

``` cpp
struct SegTree
{
    struct Node
    {
        int l, r;
        int v;
    };

#define ls (p * 2)
#define rs (p * 2 + 1)
#define tmid ((seg[p].l + seg[p].r) >> 1)

    Node seg[N * 4];

    void apply(int p, )
    {
        ;
    }
    
    void pushup(int p)
    {
        ;
    }
    
    void pushdn(int p)
    {
        apply(ls);
        apply(rs);
        clear lazy;
    }
    
    void update(int ql, int qr, int p = 1)
    {
        if(qr < seg[p].l || ql > seg[p].r) 
            return;
        if(ql <= seg[p].l && qr >= seg[p].r)
        {
            apply(p);
            return;
        }
        
        pushdn(p);
        update(ql, qr, ls);
        update(ql, qr, rs);
    	pushup(p);
    }
    
    
    int ask(int ql, int qr, int p = 1)
    {
        if(qr < seg[p].l || ql > seg[p].r)
            return 0;
        if (ql <= seg[p].l && qr >= seg[p].r)
        {
            return;
        }

        pushdn(p);
        return ask(ql, qr, ls) + ask(ql, qr, rs);
    }


    void build(int l, int r, int p = 1)
    {
        seg[p].l = l;
        seg[p].r = r;

        if (l == r)
        {
            return;
        }
        build(l, tmid, ls);
        build(tmid + 1, r, rs);
        pushup(p);
    }
};
```





### 动态开点





### 主席树

``` cpp
struct SegTree
{
    struct Node
    {
        int lson, rson;
        ll lazy; // 标记永久化
        ll v;
    };

#define ls (p * 2)
#define rs (p * 2 + 1)
#define tmid ((seg[p].l + seg[p].r) >> 1)
#define mid (((l) + (r)) >> 1)

    Node seg[N * 35];
    int cnt = 0;
    int tid[N];

    void clear()
    {
        memset(seg, 0, sizeof(seg));
        memset(tid, 0, sizeof(tid));
        cnt = 0;
    }

    int newNode(int lson, int rson, int v, ll sum)
    {
        seg[++cnt] = {lson, rson, v, sum};
        return cnt;
    }

    int update(int l, int r, int p, int pos, ll x)
    {
        if (l == r)
            return newNode(0, 0, 0, x);
        int lson, rson;
        if (pos <= mid)
        {
            lson = update(l, mid, seg[p].lson, pos, x);
            rson = seg[p].rson;
        }
        else
        {
            lson = seg[p].lson;
            rson = update(mid + 1, r, seg[p].rson, pos, x);
        }
        return newNode(lson, rson, seg[p].lazy, seg[lson].v + seg[rson].v);
    }

    // 区间修改 / 标记永久化
    int update(int l, int r, int p, int ql, int qr, ll x)
    {
        if (qr < l || ql > r)
            return p;
        if (ql <= l && qr >= r)
        {
            ll v = seg[p].v + x * (r - l);
            return newNode(seg[p].lson, seg[p].rson, x + seg[p].lazy, v);
        }
        int lson = update(l, mid, seg[p].lson, ql, qr, x);
        int rson = update(mid + 1, r, seg[p].rson, ql, qr, x);
        return newNode(lson, rson, seg[p].lazy, seg[lson].v + seg[rson].v);
    }

    // 区间第 k 大
    int ask(int l, int r, int lp, int rp, int k)
    {
        if (l == r)
            return l;
        ll x = seg[seg[rp].lson].v - seg[seg[lp].lson].v;

        if (k <= x)
            return ask(l, mid, seg[lp].lson, seg[rp].lson, k);
        else
            return ask(mid + 1, r, seg[lp].rson, seg[rp].rson, k - x);
    }

    // 区间和
    ll ask(int l, int r, int p, int ql, int qr, ll lazy)
    {
        if (qr < l || ql > r)
            return 0;
        if (ql <= l && qr >= r)
            return lazy * (r - l + 1) + seg[p].v;
        return ask(l, mid, seg[p].lson, ql, qr, lazy + seg[p].lazy) + ask(mid + 1, r, seg[p].rson, ql, qr, lazy + seg[p].lazy);
    }
} segT;
```



### 可持久化并查集





### 可持久化Trie











### 树状数组

``` cpp
struct BitTree
{
    const static int R = N;
    int a[R];

    void add(int pos, int x)
    {
        while (pos < R)
        {
            a[pos] += x;
            pos += lowbit(pos);
        }
    }

    int sum(int pos)
    {
        int ans = 0;
        while (pos)
        {
            ans += a[pos];
            pos -= lowbit(pos);
        }
        return ans;
    }

    // 可重复集合第k大.
    int kth(int k)
    {
        int now = 0;
        for (int i = 18; i >= 0; i--)
        {
            if (a[now + (1 << i)] < k)
            {
                k -= a[now + (1 << i)];
                now += 1 << i;
            }
        }
        return now + 1;
    }
} bt;
```















## 哈希

``` cpp
namespace QwQHash
{
    // 根据生日悖论, 选根号P左右的数基本就会重复. 所以模得用1e18范围的
    const ull P1 = 1000000993; 
    const ull P2 = 1000111121;
    const ull P1_64 = 4000000000000000037ll;
    const ull P2_64 = 4000000000000000121ll;
    const ull B1 = 1313141;
    const ull B2 = 2333377;

    using T = int;
    ull b1[N], b2[N], b3[N];

    void init(int n)
    {
        b1[0] = b2[0] = 1;
        rep(i, 1, n) b1[i] = b1[i - 1] * B1;
        rep(i, 1, n) b2[i] = b2[i - 1] * B2;
        rep(i, 0, n) b3[i] = rnd();
    }

    // ((ax + b) mod 2^w) / 2^(w - m)  模 2^w 的高m位
    ull hash1(ull x, ull i, ull w = 58, ull m = 35)
    {
        return (x * b3[i] + b3[i - 1]) >> (w - m);
    }

    // 字符串的多项式哈希. 可以快速计算子串的哈希值
    ull hash_string1(const string &s)
    {
        ull ans = 0;
        for (int i = 0; i < s.size(); i++)
            ans += (s[i] - 'a' + 1) * b1[i] % P1_64;
        return ans;
    }

    // 异或哈希. 可以避免取模
    ull hash_string2(const string &s)
    {
        ull ans = 0;
        for (int i = 0; i < s.size(); i++)
            ans ^= hash1(s[i], i);
        return ans;
    }

    // 多重集合哈希
    ull hash_multiset(const vector<int> &a)
    {
        vector<int> b(a);
        sort(b.begin(), b.end());
        ull ans = 0;
        for (int i = 0; i < a.size(); i++)
            ans += b[i] * b1[i] % P1_64;
        return ans;
    }

    namespace HashTree
    {
        const int V = N;
        int r1, r2; // 两个重心
        int sz[V], son[V];

        void dfs(int u, int fa, int n)
        {
            sz[u] = 1;
            for (auto v : g[u])
            {
                if (v == fa)
                    continue;
                dfs(v, u, n);
                sz[u] += sz[v];
                son[u] = max(son[u], sz[v]);
            }
            son[u] = max(son[u], n - sz[u]);
            if (!r1 || son[u] < son[r1])
                r1 = u, r2 = 0;
            else if (son[u] == son[r1])
                r2 = u;
        };

        ull calc(int u, int fa)
        {
            vector<ull> son_hash;
            sz[u] = 1; // 换了根要重新确定形态
            for (auto v : g[u])
            {
                if (v == fa)
                    continue;
                son_hash.push_back(calc(v, u));
                sz[u] += sz[v];
            }
            sort(son_hash.begin(), son_hash.end());
            ull ans = sz[u];
            for (int i = 0; i < son_hash.size(); i++)
                ans += son_hash[i] * b1[i] % P1_64;
            return ans;
        }

        // 无根树哈希. 先找重心, 再哈希
        ull hash_tree(int n)
        {
            fill(son + 1, son + 1 + n, 0);
            fill(sz + 1, sz + 1 + n, 0);

            dfs(1, 0, n);
            ull ans = calc(r1, 0);
            dbg(ans);
            if (r2)
                ans = min(ans, calc(r2, 0));
            dbg(r1, r2);

            r1 = r2 = 0;
            return ans;
        }
    }
}
```

